# Лабораторная работа по предмету "Облачные технологии и услуги"

1. **Dockerfile with bad practices**

    ```
    FROM python:latest

    USER root

    WORKDIR /app

    COPY . .

    RUN pip install --no-cache-dir -r requirements.txt

    CMD ["python", "app.py"]
    ```

3. **Bad practices image container**

    ```docker build -t bad-image -f BadDockerfile .```

    ![alt text](<images/1.png>)

4. **Dockerfile with good practices**

    ```
    FROM python:3.11-slim

    RUN useradd -ms /bin/bash user

    USER user

    WORKDIR /app

    COPY requirements.txt .

    RUN pip install --no-cache-dir -r requirements.txt

    COPY app.py .

    CMD ["python", "app.py"]
    ```

5. **Good practices image container**

    ```docker build -f GoodDockerfile -t good-image .```

    ![alt text](<images/2.png>)

6. **Результаты и вывод**

    ```docker images```

    ![alt text](<images/3.png>)

    Образ, созданный на основе “плохого” Dockerfile собирается медленнее и весит больше образа, созданного на основе “хорошего”.


## Dockerfile Bad Practices

### 1. Не указывать конкретную версию образа.

Образ может измениться, контейнер начнет работать неправильно или и вовсе крашиться.

### 2. Запускать контейнер от root.

От рута (по умолчанию) можно натворить плохих дел или вовсе эскейпнуться из контейнера.

### 3. Установливать зависимости после копирования файлов.

Увеличение размеров и времени сборки образа из-за невозможности нормального кеширования.

### 4. Копировать абсолютно все файлы в контейнер и не использовать .dockerignore (тем самым увеличивая размер dockerfile).

Увеличение размеров и времени сборки образа из-за лишних файлов.

## Dockerfile Good Practices

### 1. Использовать теги образа.

Устанавливает точную версию и вид образа.

### 2. Создать отдельного пользователя, чтобы не запускать контейнер от root.

Банально повышает безопасность, т.к. у юзера меньше прав.

### 3. Cначала устанавливать зависимости, а потом уже копировать файлы.

Фикс кеширования.

### 4. Копировать только нужные нам файлы и добавлять .dockerignore файл.

Избавляет от ненужных файлов в образе.

## Плохие практики по работе с контейнерами.

### 1. Не выполнять больше одного процесса в контейнере.

Тяжело отлаживать несколько процессов. Контейнеры идеально подходят для 1 приложения.

### 2. Не хранить данные в контейнерах.

Лучше на маунтах, иначе можно потерять.

### 3. Не использовать IP адреса

Лучше обращаться по доменным именам, т.к. IP адреса у контейнеров всегда разные.

## Со звездочкой

### docker-compose with bad practices

```docker compose -f bad-docker-compose.yml up```

![alt text](<images/4.png>)

Здесь можно наблюдать открытые секреты в переменных окружения, проброс ненужных портов, отсутствие порядка запуска, нет менеджмента ресурсов, у контейнеров случайные имена.

### docker-compose with good practices

```docker compose -f good-docker-compose.yml up```

![alt text](<images/5.png>)

Исправлены плохие практики: секреты переехали в специальный раздел, открыт лишь нужный порт, присутствует порядок запуска и ресурсы ограничены, имена зафиксированы.

### Isolated containers

``` docker compose -f isolated-docker-compose.yml up```

![alt text](<images/6.png>)

Изначально контейнеры по умолчанию находятся в одной сети. Вместо этого я создал 2 сети для каждого контейнера и поместил их туда. Теперь они не видят друг друга.
